==================
第三课  排序和查找
==================

一、冒泡排序
------------

1. 算法：

1) 比较相邻的元素，如果第一个比第二个大，就交换它们两个；
2) 对每一对相邻元素做同样的工作，从开始的第一对到结尾的最后一对。经过这一步，最后的元素将是最大值；
3) 针对所有的元素重复以上步骤，除了最后一个；
4) 持续每次对越来越少的元素重复以上步骤，直至没有元素需要交换。

图示：冒泡排序.swf

范例：sort.h、sort.c、sort_test.c

2. 评价：平均时间复杂度，O(N^2)。稳定。对数据有序性非常敏感。

二、插入排序
------------

1. 算法：

1) 从第一个元素开始，该元素可以认为已经被排序；
2) 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3) 若该元素大于新元素，则将该元素移到下一位置；
4) 若该元素小于或等于新元素，则将新元素插入到该元素后；
5) 重复步骤2，直至处理完所有元素。

图示：插入排序.swf

范例：sort.h、sort.c、sort_test.c

2. 评价：平均时间复杂度，O(N^2)。稳定。对数据有序性非常敏感。冒泡排序是值交换，而插入排序是值移动，因此插入排序要优于冒泡排序。

三、希尔排序
------------

1. 算法：

1) 将要排序的一组数按某个增量分成若干组，每组中记录的下标相差该增量，对每组中全部元素进行插入排序；
2) 用一个较小的增量重新分组，在每组中再进行排序；
3) 重复以上步骤，当增量减到1时，整个要排序的数被分成一组，完成最终排序。

2. 另一种解释：将数组列在一个表中并对列进行插入排序。重复这过程，不过每次用更长的列来进行，最后整个表就只有一列了，完成最终排序。

3. 关于分组步长的选择：

1) 小数组步长序列：1, 4, 10, 23, 57, 132, 301, 701, 1750, ...
2) 大数组步长序列：斐波那契数列除去0和1将剩余的数以黄金分割比的两倍的幂进行运算得到的数列，1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713, ...

图示：希尔排序.swf

范例：sort.h、sort.c、sort_test.c

4. 评价：平均时间复杂度，O(NlogN)。不稳定。比冒泡排序快5倍，比插入排序大致快2倍，极端情况下比快速排序和归并排序慢很多。

四、选择排序
------------

1. 算法：首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。

图示：选择排序.swf

范例：sort.h、sort.c、sort_test.c

2. 评价：平均时间复杂度，O(N^2)。不稳定。对数据有序性不敏感。虽然比较次数多，但数据交换少，所以一般情况下快于冒泡排序。

五、快速排序
------------

1. 算法：

1) 从数列中挑出一个元素，称为基准；
2) 重新排序数列，所有比基准小的元素摆放在基准前面，所有比基准大的元素摆在基准的后面(相同的元素可以放到任一边)，这个过程称为分区；
3) 以递归方式对小于基准的元素分区和大于基准的元素分区分别进行排序。

50
0 10 80 30 60 50 40 70 20 90 100
i
              p
                             j

0 10 20 30 40 50 80 70 60 90 100
              i
              p
              j


图示：快速排序.swf

范例：sort.h、sort.c、sort_test.c

练习：qsort.c

2. 评价：平均时间复杂度，O(NlogN)。不稳定。如果每次能均匀划分序列，它是最快的排序算法。

六、归并排序
------------

1. 算法：

1) 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2) 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3) 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4) 重复步骤3直到某一指针达到序列尾；
5) 将另一序列剩下的所有元素直接复制到合并序列尾。

图示：归并排序.swf

范例：sort.h、sort.c、sort_test.c

2. 评价：平均时间复杂度，O(2NlogN)。稳定。对数据有序性不敏感。非就地排序，需要与待排序序列一样多的辅助空间，不适用于大数据量的排序。

七、线性查找(顺序查找)
----------------------

1. 算法：从表头开始，一次将每一个值与目标元素进行比较，最后，或者查找到目标，或者达到表尾且目标不在表中。

范例：find.h、find.c、find_test.c

2. 评价：平均时间复杂度，O(N)。若数据是无序的，则只能采取顺序查找。

八、二分查找(折半查找)
----------------------

1. 算法：首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

范例：sort.h、find.h、sort.c、find.c、find_test.c

2. 评价：平均时间复杂度，O(logN)。要求必须采用顺序存储结构，且必须按关键字大小有序排列。

练习：findex.c