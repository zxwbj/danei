项目：DMS数据采集系统
需求分析->概要设计->详细设计->编写代码->测试验证
->产品发布->工程实施->售后支持
瀑布式项目流程
迭代式项目流程
敏捷式项目流程
一、需求分析
1.目标：《需求规格说明书》按照软件工程的要求，复述、整理、提炼用户的需求，得到用户的认可。
2.用户化的需求文档和专业化的需求文档。
3.用例、事件流、异常流、前置条件、后置条件。
4.简单的演示程序。
二、分析设计
1.目标：《概要设计》和《详细设计》。
2.面向过程的设计框架：基于事件流。
3.面向对象的设计框架：基于数据的状态。
1)面向对象设计的首要任务就是找对象。
事件流：
按照事件节点描述
按照数据节点描述
事件和数据并重的描述
例如：
读取-文件-插入-记录
事件-数据-事件-数据
理论：根据需求事件流中的名词和动词找对象。
实践：
根据需求事件流中的事件找对象，事件由对象触发，责任分配，关注对象的行为――接口驱动。
根据需求事件流中的数据找对象，关注对象的属性――模型驱动。
根据需求异常流中的事件找对象，关注异常处理的过程――异常驱动。
2)形成初始的类
类名、成员变量和成员函数名
FileReader
      path
      read
4.根据前面的分析和设计绘制系统框架图
5.细化每一个变量、函数、类，针对它们的类型和接口给出明确的定义。
6.绘制类图、时序图、状态图、活动图。根据需要辅以部署图、组件图等等。
三、案例
数据采集客户机：读取登录日志文件，通过网络发送给数据采集服务器。
数据采集服务器：从网络接收发自数据采集客户机的登录信息，存入数据库。
(一)客户机
1.用例名称：数据采集客户机
2.参与者：系统管理员（有界面）、自动任务管理器（无界面）
3.事件流
备份系统日志，产生一个备份文件，备份文件名以日期和时间作为后缀，如：wtmpx.20140722110800，同时将原日志文件清空。
读取备份文件，产生登入和登出记录：用户名、IP地址、登录类型（登入或登出）、时间、进程标识等。
根据用户名、IP地址和进程标识匹配登入和登出记录，形成一条登录记录：用户名、IP地址、登入时刻、登出时刻、登录时段（登出时刻-登入时刻）。
对于有登入没有登出的记录，保存在登入文件中，以后采集时再做匹配。
对于有登出没有登入的记录，计费系统上线之前登入，不予处理。
根据服务器的IP地址和端口号，建立连接。
把匹配好的登录记录发送到服务器端。
4.异常流
备份日志失败，终止采集。
读取备份文件失败，终止采集。
匹配登录记录失败，有登入没登出计入登入文件下次匹配，有登出没登入，直接丢弃。
连接服务器失败，保存匹配记录，下次再发。
发送登录记录失败，保存剩余记录，下次补发。
5.前置条件
日志文件：/var/adm/wtmpx
有登入没登出的记录保存在文件：./logins.dat
连接服务器失败或发送失败保存匹配记录的文件：./fail.dat
备份日志文件：./wtmpx.YYYYMMDDhh24mmss
服务器的IP地址和端口号：192.168.0.26/8888
6.后置条件：匹配登录记录
7.绘制用例图
8.绘制系统框架图
9.找对象
登入登出日志记录(LogRec)
   登录名(logname)
   登录IP(logip)
   登录进程(pid)
   登入登出时间(logtime)
匹配日志记录(MLogRec)
   登录名(logname)
   登录IP(logip)
   登录进程(pid)
   登入时间(logintime)
   登出时间(logouttime)
   登录时段(durations)
客户机异常(ClientException)
 |  异常信息(msg);
+->备份异常(BackupException)
+->读取异常(ReadException)
+->存储异常(SaveException)
+->网络异常(SocketException)
+->发送异常(SendException)
客户机(Client)
   日志读取器(LogReader)
      日志文件名(logFile)
      登入文件名(loginsFile)
      备份文件名(backupFile)
      登入记录集(logins)
      登出记录集(logouts)
      匹配记录集(logs)
      读取日志(readLog)     
   日志发送器(LogSender)
      失败文件名(failFile)
      服务器IP地址(ip)
      服务器端口号(port)
      套接字(sockfd)
      发送日志(sendLog)      
   数据采集(dataMine)
10.绘制类图
11.绘制时序图
12.绘制活动图/状态图
(二)服务器
1.用例名：数据采集服务器
2.参与者：系统管理员
3.事件流
1)接收客户机数据（网络）
A.建立服务器侦听socket
B.等待并接受客户机的连接请求
C.为该采集点创建线程接收采集到的数据
D.把数据放入缓冲区，如果缓冲区满则暂停
2)保存收到的数据（数据库：文件/Oracle）
A.连接数据库/打开文件
B.从缓冲区中提取数据，如果缓冲区空则暂停
C.保存到数据库或文件中
D.关闭数据库或文件
4.用例图
5.类图
-------------------------------------------------------------
条件变量
1.创建并初始化条件变量
int pthread_cond_init (
  pthread_cond_t* cond, // 输出，条件变量ID
  const pthread_condattr_t* attr // 输入，条件变量属性
);
成功返回0，失败返回-1。
pthread_cond_t cond =
  PTHREAD_COND_INITIALIZER;
2.销毁条件变量
int pthread_cond_destroy (
  pthread_cond_t* cond // 输入，条件变量ID
);
成功返回0，失败返回-1。
3.等待条件变量
int pthread_cond_wait (
  pthread_cond_t* cond, // 输入，条件变量ID
  pthread_mutex_t* mutex // 输入，互斥体ID
);
使调用线程进入睡眠状态（被移出调度序列，即阻塞于内核之中），同时对参数互斥体解锁。
成功返回0，失败返回-1。
4.唤醒在条件变量中睡眠的线程
int pthread_cond_signal (
  pthread_cond_t* cond // 输入，条件变量ID
);
从参数条件变量中唤醒任意一个处于睡眠状态的线程，如果
该线程能够加锁原先的互斥体，则从此函数中返回，否则继
续阻塞于等待加锁完成。
成功返回0，失败返回-1。
int pthread_cond_broadcast (
  pthread_cond_t* cond // 输入，条件变量ID
);
从参数条件变量中唤醒所有处于睡眠状态的线程，只有其中
对原先的互斥体加锁成功的那个线程从该函数中返回，其它线程继续阻塞于等待加锁完成。
成功返回0，失败返回-1。
注意：
一个线程被从条件变量中唤醒以后，在其重新获得先前被释
放的互斥锁之前，其它线程有可能执行锁区间的代码。因此
从pthread_cond_wait()函数返回以后，有必要对导致该线
程睡入条件变量的条件再判断一次。
if->while
-------------------------------------------------------------
线程封装
对象化线程=线程+面向对象+多态
-------------------------------------------------------------
6.时序图
7.编写代码






