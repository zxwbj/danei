模板和STL
一、函数模板
1.定义函数模板
1)函数模板代表一个函数家族。它的表示（外形）看起来和普通函数很相似，唯一区别就是有些函数元素是未确定的，这些元素将在使用时被参数化――参数化类型或者类型参数。
2)模板参数必须用如下形式的语法来声明：
template<typename 类型形参1, typename 类型形参2, ...>
3)类型形参的名称和其它合法标识符的命名规则一致。与类型形参相对应的类型实参可以是基本类型，如int、double，也可以是类类型，如string、Student。
4)声明类型形参使用了关键字typename，也可以使用class，在这种语境下两个关键字完全等价。但是这里不可以使用struct关键字。
2.使用函数模板
1)一般形式：函数模板名<类型实参1, 类型实参2, ...> (实参表);
2)通常而言，编译器并不会把模板直接编译成一个可以处理任何类型的单一实体，而是对于使用函数模板时所提供的每一种类型实参，产生一个不同的实体。这种用具体类型代替模板参数的过程叫做实例化。该过程的结果就是产生了一个模板实例。
3)试图基于一个不支持模板内部所使用操作的类型实例化一个模板，将会导致一个编译错误。
4)每个函数模板至少被编译两次。第一次是在实例化以前，只检查模板本身的语法是否正确，并不生成二进制代码。第二次是在实例化期间，结合所提供的类型实参，再次进行语法检查，若检查通过则产生二进制代码。这个过程被称为二次编译或后期编译。
5)一定要保证当编译器看到模板被使用时，一定能够同时看到该模板的定义。
3.函数模板参数的隐式推断
int a[10];
a[5] = 5; -> *(a+5) = 5;
cout << sizeof (a) << endl; // 40
void foo (int* x); -> sizeof (x) -> 4
foo (a); // 首地址
void bar (int(&x)[10]); -> sizeof (x) -> 40
foo (a); // 整个数组
4.函数模板和普通函数一样，其调用参数也可以带缺省值
template<typename T>
void foo (T x, int y = 1234) { ... }
5.函数模板的重载
主要用于在满足大多数类型的同时，为某些特殊类型提供一个单独的实现。
二、类模板
1.定义类模板
template<typename 类型形参1, typename 类型形参2, ...> class 类模板名 { ... };
在类模板内部，成员变量的类型，成员函数的参数、返回值及其内部局部变量的类型，基类的类型，甚至内部类的类型等，都可以被定义为类型参数。
template<
  typename A
  typename B
  typename C
  typename D
  typename E
  typename F>
class Dummy : public E {
public:
  B foo (C c) {
    D d;
    return B ();
  }
  typedef F G;
private:
  A m_a;
};
Dummy<int, char, float, double, Student, string>
class Dummy : public Student {
public:
  char foo (float c) {
    double d;
    return char ();
  }
  typedef string G;
private:
  int m_a;
};
为了定义类模板的成员函数，必须指定该成员函数是一个函数模板，而且还需要使用类模板的完整类型限定符。
template< typename 类型形参1, ...>
返回类型 类模板名<类型形参1, ...>::成员函数名 (形参表) {
  ...
}
2.类模板的使用
1)类模板名<类型实参1, ...> 对象名 (构造实参表);
类模板--实例化-->类--实例化-->对象
   编译器(编译期间)  处理器(运行期间)
2)类模板的模板参数不能隐式推断，必须显式指明。
3)类模板的模板参数可以带有缺省值，但是函数模板的模板参数不能带有缺省值。与函数参数的缺省值一样，类模板的缺省参数必须靠右，即如果某一个模板参数带有缺省值，那么它后面的所有模板参数必须都带有缺省值。
4)类模板中，只有那些被调用的成员函数才会被实例化（被编译成二进制代码）。某些类型虽然并没有提供类模板所需要的全部功能，但照样可以实例化该类模板，只要不直接或间接调用那些依赖于未提供功能的成员函数即可。
3.类模板的静态成员变量，在该类模板的每个实例化类中，都有一份独立的拷贝。















