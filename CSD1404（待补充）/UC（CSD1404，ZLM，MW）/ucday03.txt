回顾：
  静态库和共享库 - .a 和 .so ，开发中使用共享库居多。要求必须掌握共享库的创建和使用。
  C程序员的错误处理方式 - 用返回值代表是否出错，出了什么错 用错误码和错误信息。errno 针对错误码，但不是所有的函数都使用 errno，线程就不使用。perror()、strerror()可以错误码转换成错误信息。
  返回值代表出错有4种情况：
   1 返回int，如果返回的数据不可能是负数，用-1代表出错，数据正常返回。
   2 返回int，如果返回的数据可能是负数，用-1代表出错，用0代表正确，数据用传入指针参数的方式带回来。
   3 返回是指针(void*/char*/int*)，直接用返回NULL代表出错，其他正常返回。(有些函数用-1代表出错)
   4 无需考虑错误时，该返回什么就返回什么，如果不需要返回直接写void。
  环境变量和环境表
  环境表是一个字符指针数组，存储了所有的环境变量。需要环境变量时，只需要写上 extern char** environ; 即可。
  主函数中，也可以使用第三个参数，第三个参数就是环境表的首地址。
  环境表的相关函数： setenv() putenv() getenv() unsetenv()
  
  今天：(Unix/Linux系统下的编程)
   内存管理 - Unix内存管理的机制(虚拟内存地址空间)
                    Unix的内存管理的相关函数
                    Unix系统下 进程的内存空间划分

   Unix系统提供了内存管理的函数，结构和方式如下：   
   STL   ->  自动分配、自动回收(Java语言也是自动管理)
     |
  C++   ->   new分配、delete回收
     |
 C语言  ->   malloc()分配、free()回收
     |
Unix系统函数  ->  sbrk()和brk()  分配和回收
     |
Unix系统函数  ->  mmap()分配、munmap()回收
     |                                                            (用户层)
-----------------------------------------------------------
Unix内核层函数  -> kmalloc() vmalloc()  (内核层)
     .....
 6个函数 - 
   malloc() free() sbrk() brk() mmap() munmap()
 
 代码运行必须借助CPU和内存，CPU是中央处理器，CPU可以操作自己的寄存器(CPU寄存器不参与内存地址)，可以操作内存，但不能直接操作硬盘，硬盘的数据必须交换到内存中才能被CPU使用。

 进程内存空间的划分
   进程和程序
    代码编译连接后得到的是程序，程序是硬盘上的文件。
    进程就是在内存中运行的程序，CPU运行的是进程。程序必须加载到内存中，变成进程才能运行。
    一个程序可以多次运行，启动多个进程；一个进程可以运行多个程序。
   一个进程的内存空间划分：
    代码区 - 存程序的代码(函数)，函数指针就是指向代码区的，代码区 是只读区域。
    全局区 - 存储全局变量、static的局部变量也在这里。可读可写。
    BSS段 - 存储未初始化的全局变量(没=的)。
    栈区(堆栈区 stack) - 存储非static局部变量，函数的参数(形参)。栈区的内存是自动管理。
    堆区(heap) - 也叫自由区，是程序员唯一能全面管理的区域，堆区 系统不会做任何的工作。堆区内存的分配和回收都由程序员完成。malloc()和free()针对的是堆区。
    只读常量区 - 很多书都是并入代码区，只读区域。存储字符串的字面值("aaa")，const修饰的全局变量。字符串的相同字面值在只读常量区只存一个。

  注：全局区和BSS段都是main()运行之前就分配好的，但BSS段会在main()运行之前自动清0。
   
  Unix内存管理的机制(虚拟内存地址空间)
   Unix内存管理使用了虚拟内存地址空间的机制，每个进程启动后都先天具有 0到4G-1的虚拟内存地址(32位系统)，这些虚拟内存地址本质就是整数，不需要额外的分配，也不占用内存的资源(没有分配对应的物理内存)。虚拟内存地址不能直接存储数据，必须映射到物理内存或硬盘上的文件才能真正存储数据，否则引发 段错误。
   程序员 接触到的 都是虚拟内存地址，目前拿不到真实的物理内存地址。
   0到4G-1的虚拟内存地址分成两部分：0-3G的用户空间，3G-4G的内核空间。用户空间不能直接访问内核空间，但可以通过系统提供的特定函数(系统调用)访问内核空间。
   内存分配和回收 是以 字节为基本单位，内存的映射是以 内存页为基本单位，一个内存页一般是 4k字节(4096)。获取内存页的大小可以使用函数 getpagesize()。

  Linux系统中，几乎一切都可以看成文件，内存也有文件与之对应。/proc/进程ID 目录下就是进程对应的文件。取进程的id用函数getpid()。如果进程结束，这个目录也会消失。
  
   用 cat   /proc/进程ID/maps 可以查看内存中页的情况。
  6个内存区域的排列，从小到大的次序：
   1 代码区 (0x 08048XXX)
   2 只读常量区
   3 全局区
   4 BSS段
   5 堆区(0x 08/09) - 用户空间的开头 (0)
   6 栈区(0x bfXX XXXX) - 用户空间的尽头(3G)
 
   C语言的字符串(在Unix系统) 非常重要
   - 任何的语言都会使用字符串，而且是非常重要的类型。
   - 任何的项目都以字符串做输入，并且会有字符串的各种处理
   - 任何靠谱公司的笔试和面试 必然会有字符串的处理。
   C程序员没有string类型，字符串用的是 char* 或char[]
  引发段错误的常见原因：
   1 使用了没有映射到物理内存/硬盘文件的 虚拟内存地址。
   2 对没有权限的内存区域进行操作。(修改只读区)

  '0' - '9' 数字字符 如何转换成对应的整数？  -'0'
  
  malloc()是C程序员分配内存最常用的方式，在Unix系统中，申请小块内存时，一次映射33个内存页；而在申请大块内存时，会分配比申请的多一点。

  

