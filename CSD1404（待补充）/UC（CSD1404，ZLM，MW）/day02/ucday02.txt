回顾：
   介绍了一下Unix系统和Linux系统
   Gcc编译器 - 预处理、编译、汇编、连接
   gcc -E 
   gcc -S
   gcc -c
   gcc -o
   gcc 
   gcc -I
   gcc -Wall
   预处理的指令：
    #include
    #define
    #if  #elif  #else  #endif
    #ifndef  #ifdef  #endif
    #warning   #error
    #pragma 三种用法:  
    #pragma GCC dependency 
    #pragma GCC poison
    #pragma pack(n)
  头文件和环境变量
   头文件(.h)中放各种声明，实现放在 源文件(.c)中。
   系统的头文件都可以找到，自定义的头文件可以用以下三种方式搞定：
    1 用""，""中可以加路径
    2 gcc -I路径 
    3 配置环境变量：CPATH
   环境变量就是系统启动后，有些数据加载到了内存中，以环境变量的形式存在。
今天：
   静态库和共享库
   C程序员如何处理错误
   环境变量和环境表
   
   大型项目会产生很多的.o文件，从项目管理的角度和应用角度都比较麻烦，系统提供了把这些.o文件打包成一个文件的机制，就是 库文件，Windows/Unix/Linux都支持库文件。库文件分为 静态库和共享库(动态库)。包括操作系统自己的函数 也是存在 库文件中。Unix/Linux系统中，静态库是 .a 文件，共享库 是 .so文件。可执行文件必须有main()，而共享库和静态库 可以没有main()。项目开发 通常就是 提供几个头文件和几个 库文件。
   静态库和共享库的区别：
    静态库是代码的归档，在使用静态库时采用的方式是直接复制代码段到目标程序中。使用静态库的优点速度快，缺点就是太浪费空间，并且不利于修改和维护。   
   共享库是代码的归档，在使用共享库是采用的方式是把代码段在共享库中的地址放入目标程序中。使用动态库的优点节省空间，并且修改和维护比较便利，缺点是速度稍慢。
   实际开发中，使用共享库是 绝对主流。  
   静态库的使用
    1 创建静态库
      1.1 写源代码，然后保存退出。
      1.2 编译源代码，生成 .o文件。 gcc -c add.c
      1.3 ar -r命令创建静态库文件。
         ar -r 静态库文件名 所有的.o文件
        注：静态库文件名可以随便起，但最好遵循规范，静态库文件的规范以lib开头，以.a结束，中间放 库名。
        ar -r libmyku.a add.o 
    2 调用静态库
     2.1 写调用源代码，保存退出。
     2.2 编译源代码，生成 .o文件。gcc -c test.c 
     2.3 连接 .o文件和库文件，有三种方式：
       a 直接连接法  gcc test.o libmyku.a
       b 双L连接法 
         gcc test.o -l库名 -L库所在的路径
       c 单l连接法
        把库所在的路径配置到LIBRARY_PATH中，然后只用l指定库名即可。
         gcc test.o -l库名

   共享库 (动态库) 的使用步骤
    1 创建共享库
      1.1 写源代码，保存退出。
      1.2 编译源代码，生成 .o文件。
        gcc -fpic -c add.c  //不加-fpic也可以
      1.3 生成共享库文件
        gcc -shared add.o -o共享库文件名
       共享库文件名有规范，以lib开头，以.so结尾，中间是库名。有些系统共享库，.so后面有.数字。
       gcc -shared add.o -olibmyku.so
    2 调用共享库
       和静态库完全一样。
   注：在运行含有共享库的可执行文件时，必须配置LD_LIBRARY_PATH确保系统能找到共享库文件。
   静态库在连接完成以后，可执行文件和库文件没有任何的关系。共享库在连接完成以后，可执行文件必须依赖于库文件才能运行函数。
   查看库文件有命令，比如：ldd命令。可以显示相关的共享库和内存的地址。
   ldd a.out 
   ldd libmyku.so
   系统还提供了额外操作共享库的函数，可以直接在程序中打开一个共享库，执行里面的函数。(了解)
   dlopen()  dlsym() dlclose() dlerror()
   
   对于 知识，分为5个阶段：
     未知、了解(听说过)、熟悉(大概明白)、掌握(能用)、精通
    课下的目的 就是 从熟悉到掌握
   
  错误处理
   程序员写项目，要求很严谨。项目包括正常的流程和非正常流程，其中，错误处理就是非正常流程。
   错误处理是项目的正常的组成部分。C语言之后的很多语言(C++/Java/...)都是用 异常(Exception)机制 设计和处理错误，C语言没有异常机制，是用返回值代表是否出错，错误处理的代码自己写。
   man手册可以查什么？
    1 可以查系统命令，比如：ls
    2 可以查函数。(如果函数和命令重名，后面加2或3)
    3 可以查头文件。man time.h
   英文不好的同学装翻译软件，用 星际译王。
  用返回值代表出错的4种情况：
   a 如果函数的返回值是int，并且返回的数据不能是负数
，出错返回-1。
   b 如果函数的返回值是int，并且返回的数据可能是负数，正确返回0，错误返回-1， 数据用指针带回来。
   c 如果函数的返回值是指针，用NULL代表出错。
   d 如果不需要考虑出错情况或不可能出错，返回值正常返回即可，无需返回的用void。
  注：上面四种情况不是绝对的语法，只是一般的经验，可以不遵守。 
  关于函数的数据返回，有两种方式：
   1 用return 语句直接返回。
   2 用指针 把数据带回来。
  练习：
   写4个函数做错误处理，用主函数测试。
   1 函数max()，计算两个整数的最大值并返回，如果这两个整数相等，返回错误。b 
   2 函数rand10()，取0-9的随机数，随机到0 返回错误。a
   3 函数printstring()，打印传入的字符串并换行。d
   4 函数iserror()，传入一个字符串，如果传入是"error"返回错误，否则返回原来的字符串。c 

  出错以后，C语言提供了一些处理错误的变量和函数：
    errno - 外部全局变量，作用是记录错误的编号
    因为错误编号计算机好存，但人看不懂，因此C提供了三个函数负责把错误编号转换成错误信息：
    perror("") - 打印错误信息，自动会找errno打印。
    printf("%m") - 打印错误信息，自动找errno。
    strerror(int 错误编号) - 把传入错误编号转成错误信息
   其中，perror()和strerror()必须会。  
   errno是错误码，是程序中共用的变量，哪里出错都改的是同一个errno。errno的值 只有在出错的时候才会改变，正确的时候不改，因此不能用errno判断是否出错。

  经验：
    返回值代表是否出错，errno代表出了什么错。
  不是所有的函数都使用 errno ，至少线程相关函数就没有使用。man手册中会说明是否使用了errno。

  所有的环境变量都存在内存中，用一个 字符指针数组 保存了所有的环境变量(char* arr[n])。字符指针数组可以用char** 代表。存环境变量的区域叫 环境表，C语言环境表用char** environ 代表，environ也是一个外部的全局变量。
但environ需要extern一下：
  extern char** environ; //这就拿到了环境表
   extern 代表 这个变量 来自于其他的文件。errno 是在errno.h中已经写了 extern 。
   环境表 以 NULL结束。很多的字符串数组都是以NULL做结束。
   
   指针的运算：
    指针支持加法和减法，以加法为例。指针类型的+1是由它指向的类型的大小 决定，比如：int* p，指向int类型，所以p+1 移动 sizeof（int）字节。
  
  环境表的操作，系统提供了以下函数：
   getenv() - 用 环境变量的名 获取 环境变量的值
   setenv()/putenv() - 设置环境变量的值
    如果环境变量已存在，putenv()会替换值，setenv()可以设置是否替换。如果环境变量不存在 都会新增
   unsetenv() - 删除环境变量，按名字删除
   clearenv() - 全部删除，基本用不到
    




