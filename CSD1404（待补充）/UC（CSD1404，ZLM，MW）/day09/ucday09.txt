回顾：
  文件 - Unix系统中用 文件描述符fd 代表一个打开的文件，fd本质是一个unsigned int(非负整数)，fd是靠 文件表对应一个文件的，文件的相关信息都是存在文件表中。
  open() 函数的功能 先打开一个文件，然后把文件的信息存入文件表中，再去文件描述符的总表中查找 未使用的最小值做新的文件描述符，这个新的文件描述符会对应文件表，把文件描述符放入描述符总表中。
  close()函数的功能是把文件描述符和文件表的对应关系从描述符总表中删除，不一定会删除文件表。文件表是否需要删除要看还有没有其他的描述符与之对应，如果有，就不会回收文件表，如果没有就会回收。
  在读写文件等应用中，文件描述符都是通过文件表中的数据进行工作的。因此，如果没有对应文件表，文件描述符就无法代表文件，只是一个整数。
  相关函数： 
   open() read() write() close() stat() access() 
   truncate() remove() rename()等 
  目录 - 在Linux中，目录也被看成了文件。
   相关函数： 
    mkdir() remove() chdir() getcwd()
    opendir()  readdir()  closedir() 
    递归操作目录和子目录
  进程
    进程就是运行在内存中的程序，进程以 进程ID (PID)做唯一标识。PID可以延迟重用，同一时刻必须唯一，已经结束的进程的PID可以在一段时间之后重新分配给其他进程。  
    

进程分为父进程和子进程，如果在进程a中启动了进程b，进程a就是b的父进程，b是a的子进程。父子进程是相对的。一个父进程可以有多个子进程，一个子进程只有一个父进程。如果父进程先结束，子进程变成孤儿进程，认init进程做新的父进程，以便回收资源。
    创建子进程的方法有两种：
     1 fork() - 通过复制父进程去创建子进程
     2 vfork() + execl() - 全新的子进程       
    fork()复制父进程除了代码区之外的所有区域，包括：堆、栈、全局区、BSS段和输入、输出缓冲区。
    fork()会返回两次，父进程返回子进程的PID，子进程返回0；如果出错只返回-1(概率极低,用户或系统的进程总数已经耗尽)。
    进程的退出有两种方式：
     正常退出: 主函数执行return;  exit();  _Exit() 最后一个线程正常结束。
   非正常退出: 被信号干掉； 最后一个线程被取消
   函数wait()和waitpid() 可以让父进程等待子进程的结束，并取得子进程的返回状态和返回值。
 今天：
   wait() 和 waitpid()都可以让父进程等待子进程的结束，并取得进程的返回状态和返回值；区别在于wait()是等待任意子进程的结束，必须等待；而waitpid()可以指定等待哪个或哪些子进程，也可以等待任意子进程，不是必须等待，可以返回错误。 
   wait()和waitpid()可以回收僵尸子进程，因此得名：殓尸工。
   pid_t waitpid(pid_t pid,int* status,int options)
    参数： pid 就是 指定等待哪些、哪个子进程；
       status 用于存储结束子进程的退出状态和退出码
       options可以设定等待或不等待。
     pid 的值：
      >0  指定等待 进程ID=pid的子进程
      -1   等待所有的子进程
      0    等待本组子进程
     <-1 等待进程组ID = -pid的子进程
    options可以是WNOHANG或0，0代表等待，WNOHANG代表不等待。
   返回： 有子进程结束返回 结束子进程的PID,出错返回-1 
     如果指定了WNOHANG，没有子进程结束时返回0。

   vfork() 和 fork() 在语法上完全一样，区别在于fork()会复制父进程的内存空间，而vfork()不复制父进程的资源，直接使用父进程的内存空间，导致父进程会阻塞(因为没内存空间用)，这种阻塞只有子进程结束或子进程调用了execl()函数才能解除。而明显 子进程结束后 返回父进程资源是没有实际意义的。
   在应用中，vfork() 基本上 都和execl()一起使用，实现父子进程代码的并行(同时运行)。vfork()创建一个新的子进程，而不提供代码和数据；代码和数据由execl()提供，execl()不能创建新的子进程，只能替换现有的进程。
  经验：
   vfork()创建的子进程如果不调用execl()，必须用exit()显式退出，否则会出错或死循环。
   vfork()创建的子进程一定 先于 父进程运行。

   execl()函数是用全新的程序替换当前进程执行的程序，但不会新建进程，而是继续使用以前的进程ID。
  execl()的用法：
   参数：第一个参数必须有，而且必须正确。是可执行文件的路径。
   第二个参数 是 执行该文件的命令。
   后面可以跟0-N个任意类型的参数(一般都是char*)
   第三个参数可以是选项，可以没有。
   第四个参数可以是命令的参数，也可以没有。
   ....
   最后一个参数用NULL，告诉程序没有参数了。
  函数成功就没有当前的代码段，因此没有返回；失败返回-1.

   练习： 验证一下execl()不会改变进程的PID。
    思路：用vfork()+execl() 创建子进程 
    在执行execl()之前打印一下子进程的PID，
    然后自己写一个 b.out ， 在b.out的代码中打印当前的PID即可(两个源文件)。
   
   信号(signal) - 以前接触的信号： ctrl+C / ctrl+\  
    子进程结束，会给父进程发信号。
    段错误、整数除以0、总线错误、硬件出错
    kill 其实不是杀进程的，是 发信号的

   信号其实就是一个 非负整数，用于实现 软件中断。信号是Unix/Linux最常用的软件中断方式。中断就是让程序停止执行当前的代码，转而执行其他的代码。中断分为 软件中断和硬件中断，信号 属于软件中断。
   kill 命令可以查看当前 系统有哪些信号。
    kill -l 
   Linux的信号 是 1-64 ，中间不保证连续；Unix的信号1-48，中间也不保证连续。而且某些信号对应的值还不同。为了保证编程的通用性，每个信号都有一个宏名称，以SIG开头。每个信号在不同系统中的宏名称是相同的。因此编程时使用宏名称有更好的通用性。比如：
   信号2  就是 ctl+c产生的信号 的宏名称 SIGINT 
   信号分为两大类：
    在Linux中，1-31是 不可靠信号，特点就是不支持排队，当同一信号多次到来时，有可能出现丢失信号的情况；
   34-64 是 可靠信号，特点是 支持排队，不会出现 信号丢失。
   信号的处理方式
     1 默认处理方式，一般情况下信号都是默认处理，但可以改变。默认处理大多数情况下都会退出进程。
     2 忽略信号，当信号到来时，不做任何的处理。
     3 程序员 自定义处理方式，只要写一个 处理函数就可以
    重点应该是 程序员自定义处理函数的方式。
    进程和进程之间可以互发信号，但有限制：当前用户只能给当前用户的进程发信号，不能给其他用户的进程发信号。root可以给所有进程发信号。
    信号9不能忽略，也不能自定义，只能默认处理。 

   信号处理和子进程
     fork()创建的子进程 与父进程的信号处理方式完全一样
     vfork()+execl()创建的子进程的信号处理方式 部分照抄父进程的处理方式： 父进程默认，子进程也默认；父进程忽略，子进程也忽略；父进程自定义处理函数，子进程改为默认处理。

    函数signal() 或 sigaction() 可以设置信号的处理方式。
大多数情况下，signal()就足够了；sigaction()是 signal()的增强版，但过于复杂。
    函数指针的用法类似函数的原型声明：
     返回类型 函数名(参数列表);
     返回类型 (*变量名) (参数列表);
     只要把函数名 换成 (*变量名)
    函数signal():
      函数指针  signal(int 信号, 函数指针);
     第一个参数就是信号，设置哪个信号的处理方式。
     第二个参数就是一个函数指针，设置自定义的处理函数或默认(SIG_DFL)或忽略(SIG_IGN)。
    返回：成功返回设置之前的处理函数，失败返回SIG_ERR
    函数指针的格式：
     void fa(int);


