回顾：
  信号量集 - 就是信号量的数组，信号量是个计数器，用于控制访问共享资源的最大并行进程总数。用法：先设置初始值，然后有进程访问就对计数减1，结束访问就对计数加1。当计数到0时，不再允许进程对资源的访问。
  信号量集的使用步骤:
   1 用ftok()获得外部的key。
   2 使用semget() 创建/获取 信号量集，得到内部ID。
   3 使用semctl() 设置信号量集中每个信号量的初始值。
   4 使用semop() 对信号量加1或减1。
   5 如果不再使用，使用semctl(IPC_RMID)删除信号量集
 网络编程(socket) 
  网络常识： IP地址、端口、常用命令ping和ifconfig
  网络编程的步骤：
   1 调用socket()，获得socket描述符(类似文件描述符)。
   2 准备通信地址，本地通信用sockaddr_un(非重点)，网络通信用sockaddr_in。注意：服务器端的通信地址是服务器自身的，客户端的通信地址也是服务器的。
   3 服务器端绑定通信地址和描述符(函数bind)，客户端要进行连接(connect)。服务器端的绑定可以认为是服务器允许客户端的连接，客户端连接时面向的是服务器。
   4 像读写文件描述符一样进行网络通信(网络中数据交互)
   5 关闭描述符。
  注：通信地址中，端口使用htons()进行本机格式转网络格式，IP地址要用inet_addr()把点分十进制(字符串)转成整数。
  练习：
   写一下 昨天最后的代码(网络编程)，不要看昨天的代码。
   重点代码一定要熟练： 
     string.c 读写文件(拷贝文件) 网络编程   

  基于TCP的网络编程 :
   tcp协议和udp协议
   TCP协议是 基于连接的(有连接)协议，在整个的网络通信过程中，无论是否有数据的交互，都要保持客户端和服务器的连接。
   UDP协议是 无连接协议，在整个网络通信过程中，只有发送数据的时候连一下，其他时候是不保持连接。
   TCP 像打电话，无论现在有没有说话都要保持连接；UDP像发短信，没有任何的连接被保持。
   TCP的优点: 会重发一切错误数据，因为可以保证数据的完整和正确。缺点是 浪费资源，当客户端数量较多时，服务器端压力过大。
   UDP的优点：服务器的压力小，资源没有太多的浪费。缺点是 从协议本身不保证数据的完整和正确(程序员也可以人为的用代码补发数据)。   TCP和UPD编程都有 固定的套路
   
  TCP的编程步骤：    

    一对多的方式
    1 服务器端：
    1.1 使用socket()得到socket描述符
    1.2 准备通信地址 sockaddr_in
    1.3 使用bind() 绑定通信地址ehsocket描述符
    1.4 监听 listen()，设置多个客户端同时连接时，等待队列的最大长度。
    1.5 等待客户端的连接，使用函数 accept()，没有客户端连接时，accept()会阻塞，有客户端连接时，返回一个新的用于交互的 socket描述符。
    1.6 读写函数 read()/write()进行交互
    1.7 关闭socket描述符(哪个用完了就关闭哪个)。
    2 客户端 
     客户端的编程步骤与前面一样，5步就可以了。

   int listen(int sockfd,int length)
    参数sockfd就是第一步的返回值，length就是等待队列的最大长度。成功返回0，失败返回-1.
   int accept(int sockfd,struct sockaddr* client,
    socklen_t* size)
   参数sockfd就是第一步的返回值，client是传出参数，用于存储连接上来的客户端的通信地址(包括IP和端口)，size是一个传入传出参数，传入通信地址的大小，传出 实际接收到的通信地址的大小。
   返回： 成功返回新的socket描述符(用于read和write)，失败返回-1。
   
   版本改良1：同时修改客户端和服务器的代码，实现效果如下：
    客户端加入输入(scanf())，可以多次输入，输入bye退出。每次输入都把数据发往服务器，同时服务器把数据回发给客户端，客户端打印从服务器回发的数据。
    (加入 输入和循环，加入 服务器和客户端数据的互发)

   版本改良2：服务器由单客户改为可以面向多个客户(永不退出，随时可以连接)。
   思路： 在服务器端加上死循环，从accept()开始。用信号关闭服务器并可以关闭sockfd。
 (不用考虑并行，一个客户端关闭后，另外一个客户能用即可)

   版本改良3：实现多客户端可以同时访问服务器。借助多进程 或 多线程实现。使用fork()实现多进程版的并行。
   思考：把某些代码移到子进程的分支中就可以实现。新增代码： fork(); if(){ }

   基于UDP的编程步骤
    UDP是无连接协议，应该不需要连接就可以发送数据。UPD可以connect()再发送数据，但这不是UDP的风格。
    UDP在发送和接收数据时，采用的特定的函数：
     发送数据时，用sendto()
     接收数据时，可以用read() / recvfrom()，区别在于read()只能读到数据，而recvfrom()可以读到数据和发送方的通信地址。
    典型的UDP的发送和接收函数是：
     sendto() 和 recvfrom()
     int sendto(int sockfd,void* buf,size_t size,
       int flag,struct sockaddr* addr, socklen_t len)
   参数：sockfd、buf和size 和 write()的参数一样；
      flag一般给0即可，addr是指向 接收方的通信地址的指针，len是通信地址的sizeof()。

     ssize_t recvfrom(int sockfd,void* buf,size_t size,
        int flag,struct sockaddr* addr, socklen_t* len)
   参数：sockfd、buf和size 和 read()的参数一样；
        flag一般给0即可，addr是用于存储 发送方通信地址的指针(传出参数)，len是传入传出参数，先传入addr的大小，再传出真实的通信地址的大小。

   UDP编程的步骤：
    1 socket()得到socket描述符
    2 准备通信地址
    3 一开始的接收方要bind()
    4 用sendto()和recvfrom() 进行数据的交互。
    5 close() 关闭描述符
  整体上说，UDP编程比TCP简单。

  UPD的练习&作业：
   实现一个 时间服务器。时间服务器是提供准确的系统时间，为其他的机器服务。时间服务器是发一个请求过去，返回当前的系统时间即可。
   系统时间以 字符串的格式发回来。关于系统时间：
    time() - 可以得到秒差格式(time_t)的当前时间
    struct tm - 可以得到年月日时分秒的格式 man time.h
    localtime() - 可以time_t 转换成 struct tm.
   时间服务器应该是死循环，用信号退出。



