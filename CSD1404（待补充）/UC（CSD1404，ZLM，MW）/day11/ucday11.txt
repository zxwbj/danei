回顾：
   信号 - 用于Unix/Linux的软件中断，信号分为可靠信号和不可靠信号。信号的使用步骤：
   1 #include <signal.h>
   2 写一个处理函数， void fa(int signo){  }
   3 在主函数中写 signal(SIGXXXX,fa);
   信号的发送方式: kill() 
   信号集 sigset_t 及其相关函数 (5个)
   信号屏蔽 - 有些关键代码不希望被信号打断，而信号的到来是无法控制的，因此采用信号屏蔽技术，延后信号的处理时间，到解除信号屏蔽时再处理。
    信号屏蔽的函数： sigprocmask()
   IPC - 进程间通信
 今天：
     管道(pipe) - 管道分为有名管道和无名管道，有名管道适用于所有的场景，而无名管道只能用于fork()创建的父子进程之间。  
     有名管道的交互媒介 是 管道文件。管道文件是一种特殊的 文件，vi/touch/open() 都无法创建管道文件。管道文件必须用 mkfifo命令/mkfifo()函数创建。
    管道文件比较特殊，本身不存储数据，而是做数据的中转，因此管道文件的读写必须同时存在时才能畅通，否则就会阻塞。管道文件里面不会存储中转的数据。
  练习：
   写一个pipea.c 和 pipeb.c ， 分别读写管道文件，读写0-99，实现IPC。(读写文件)

   消息队列、共享内存和信号量集(重点是消息队列)
   这三个统称为XSI IPC，遵循相同的规范，因此在编程上有很多的共同点。
   XSI IPC的共同点：
    1 都有一个外部的key，可以定位查找XSI IPC的结构。
    2 外部key的生成方式有三种：
      2.1 用宏 IPC_PRIVATE做key，但这种key其他进程无法获取，不能做进程间通信，因此很少使用。
      2.2 key本身就是一个整数，可以把key写入公共的头文件中。
      2.3 函数ftok()可以用一个真实存在的文件创建key。
    3 外部的key可以创建/获取 IPC结构(共享内存、消息队列和信号量集统称为IPC结构)的内部ID。使用函数xxxget()，比如：shmget()  msgget()。
    4 有了IPC结构内部的ID，就可以正常使用IPC结构。
    5 IPC结构都是由内核管理，应用程序只能通过key找到内部ID，然后用内部ID操作IPC结构。
    6 创建IPC结构时，参数中通常会包含：IPC_CREAT|权限。
    7 IPC结构都提供了一个xxxctl()函数，比如：shmctl()/msgctl()，用于查询、修改和删除IPC结构。
    IPC_STAT : 查询IPC结构
    IPC_SET : 修改IPC结构
    IPC_RMID ： 删除IPC结构 

  共享内存 - 以一块共享的内存做媒介，内核先管理一块物理内存，允许其他进程进行映射，当多个进程映射到同一块物理内存时，数据交互就完成了。共享内存是 最快的IPC。
  共享内存的编码步骤：
    1 使用ftok() 或 公共的头文件生成key（key_t类型）。
    2 用key 创建/获取 共享内存的内部ID，函数shmget()
    3 映射(挂接)共享内存，函数 shmat()
    4 操作数据
    5 解除映射(脱接)共享内存，函数shmdt()
    6 如果确保所有进程都不再使用共享内存，可以删除，函数shmctl(IPC_RMID)。
  关于IPC结构，系统也提供了相关命令：
   ipcs 命令 可以查看IPC结构
   ipcs -a 看所有   -m 共享内存  -q 消息队列 -s 信号量集
   ipcrm 命令可以删除IPC结构，删除时需要提供内部ID
   ipcrm -m ID
  IPC结构是 由 内核管理，因此如果不删除，系统会长久保留。
   int shmget(key_t key,size_t size,int flag)
   参数： key就是外部的key，ftok()的返回值
      size就是内存的大小
      flag如果新建，用IPC_CREAT|权限；如果获取 0即可

  共享内存有很大的缺点：当多个进程同时写数据时，控制起来非常的麻烦。 消息队列能很好的解决这个问题。
  共享内存的查询、修改和删除，函数shmctl()。
   共享内存的修改只能修改 权限，其他都不能修改。
   共享内存的删除只能删除 挂接数为0的共享内存，如果挂接数不为0，只能做一个删除标志，等挂接数为0时才真正删除。
  
  消息队列 - 队列，存放的是消息
   消息队列的使用方式： 首先把数据封入消息(结构体)中，然后再把消息放入队列中。这个队列由内核管理，也就是消息队列。使用队列后，多个进程读写数据就不会互相覆盖。
  消息队列的编程步骤：
    1 使用ftok()获得一个key。
    2 调用msgget() 新建或获取一个消息队列。
    3 调用msgsnd()或msgrcv()进行消息的发送和接收。
    4 如果不再使用消息队列，可以用msgctl(IPC_RMID)删除消息队列。
  
   消息队列在使用时，分为有类型消息和无类型消息，通常情况下，有类型消息更实用。
    无类型消息 支持所有的数据类型，直接把数据放入消息队列，但接收数据时无法区分。
    有类型消息 自身必须是程序员定义的结构：
   struct 结构名{ //程序员可以自定义结构名
      long mtype; //第一个成员必须是消息类型，值大于0
      ....//后面可以随便写，数据区，一般是char[]或结构
    };
   将来取消息时，可以按照消息类型取对应类型的消息。

   int msgsnd(int msgid,void* structaddr,
     size_t datasize,int flag)
    参数 msgid 是消息队列的内部ID
    structaddr是 消息结构的首地址(包括消息类型)
    datasize是 消息结构中数据部分的大小(不包括消息类型)
    flag主要包括 0(阻塞) 和 IPC_NOWAIT(非阻塞)
  注：虽然有些时候datasize包括消息的大小也不出错，但还是不包括更规范。
   返回：成功0，失败-1。

  ssize_t msgrcv(int msgid,void* structaddr,
     size_t datasize,long msgtype,int flag)
   参数：msgid 就是消息队列的内部ID
     structaddr就是接受消息的结构的地址
     datasize是 数据区的可能最大值 sizeof
    flag 就是 0 代表阻塞，IPC_NOWAIT代表非阻塞
    msgtype 代表了接收消息的类型，其值可能是：
      0     接收任意的类型的消息，标准的先入先出
      >0  接收特定类型的第一个消息
      <0  接收 类型小于等于 -msgtype的第一个消息，从小到大 接收
    返回：成功返回 接收到的数据区的大小，失败返回-1.
  综合案例需要用到的知识点：
    消息队列、文件读写、文件函数、进程的创建、信号处理
  

