回顾：
  wait()和waitpid() - 可以让父进程等待子进程的结束
  wait()比较固定，等待 任意一个子进程的结束
  waitpid()有很多的选择，可以等可以不等，可以等待指定的子进程或指定一组子进程，也可以等待任意一个子进程。
  创建子进程的第二种方法:
    vfork() + execl() - 不复制父进程的内存空间，而是执行全新的程序
  信号 - 其实就是个非负整数，用于 软件中断。信号分为可靠信号和不可靠信号，信号都有一个宏名称，以SIG开头。
  信号的处理方式有三种：
    默认、忽略和自定义
  函数signal() / sigaction() 可以设置信号的处理方式
    signal(int 信号,自定义的函数名/SIG_IGN/SIG_DFL)
   失败返回SIG_ERR，成功返回设置之前的信号处理方式
今天：
   信号 - 信号的发送方式(产生信号的来源)
   信号集和信号屏蔽 - 信号的基本内容到此为止
   信号的应用和sigaction()简介
   IPC - 进程间通信
  信号可能的生成方式：
    1 键盘发送信号(部分)
     ctrl+C  SIGINT 信号2
     ctrl+\   SIGQUIT 信号3
     ...
    2 程序运行的过程中产生信号(部分)
     段错误、总线错误、整数除以0 (一般都是程序出现错误)
     double 可以除以0，结果是 无穷
    3 kill命令发送信号(全部)
     kill -信号 进程PID
    4 系统调用提供了信号发送的相关函数：
     raise() kill() alarm() sigqueue() ....
    kill()最重要，能给任意进程发送任意信号(得有权限)。
     raise() 可以发信号，只能给本进程发信号。
     alarm()其实不是发送信号的，是过一段时间后产生一个闹钟信号SIGALRM。
     kill() 是发送信号的函数。
     sigqueue()的功能比kill()还强，能在发送信号的同时附带其他的数据。需要使用sigaction()。   
    
    int kill(pid_t pid,int signo)
     参数pid 和 waitpid()的效果一样的，包括：
      大于0   发给 进程ID = 指定pid的进程
      -1        发给 任意有权限的进程
      等于0   发给本组的所有进程
     小于-1  发给 进程组ID=-pid的 进程
    后面两个较少使用。
    signo 就是信号的值。
    返回：成功0，失败-1.
     
  alarm(): 过一段时间产生一个闹钟信号。

  sleep()和usleep()
   sleep()是让程序进入休眠，参数是休眠的秒数，但可能被 非忽略的信号 打断，此时返回 剩余的秒数。
   usleep()是 以微秒为单位的休眠。
    usleep(100000); - 休眠0.1秒

  信号集： 信号的集合，本身可以看成一个超大整数，每个二进制位代表一个信号的有无。比如：
  6 (0000 0110) 就可以代表 信号2+信号3
  倒数第N位代表信号N
  信号集的类型是 sigset_t 。
  数据结构包括： 逻辑结构、物理结构和运算结构
   逻辑结构 研究的是 逻辑上的效果(人脑中的逻辑)
   物理结构 研究的是 计算机底层怎么存放(计算机的结构)
   运算结构 研究的是 需要提供哪些功能(哪些函数)
  基本函数包括：
     创建和删除、增加数据、删除数据、修改数据和查询数据等。
   系统提供了信号集相关函数，有5个：
    sigemptyset(sigset_t *set) - 信号集清空,全置0
    sigfillset(sigset_t *set) - 信号集填满,全置1
    sigaddset(sigset_t *set, int signum) - 增加一个信号
    sigdelset(sigset_t *set, int signum) - 删除一个信号
    sigismember(const sigset_t *set, int signum) - 
      判断是否有这个信号，有返回1，没有返回0

  信号屏蔽： 信号可以让代码中断，如果现在正在执行关键性的代码，中断有可能造成各种问题。而信号的到来 是没有办法控制的，程序员不知道信号 何时会来。但可以用 信号屏蔽技术 暂时不对信号进行处理，而是在执行关键代码完毕后，解除了信号屏蔽 再进行处理。
  函数sigprocmask()负责 屏蔽信号或解除信号屏蔽。
 int sigprocmask(int how,sigset_t* new,sigset_t* old)
 参数 how就是如何屏蔽信号，可以是以下三个值：
   SIG_BLOCK : 相当于加法，新的+旧的
     A B C  +  C D E -> A B C D E
   SIG_UNBLOCK：相当于减法，旧的 - 新的
    A B C  - C D E  ->  A B
   SIG_SETMASK：就是用新的替换旧的
    A B  C    C D E -> C D E 
   应用中基本使用SIG_SETMASK。
  new是新的信号屏蔽，old是用于保存之前的信号屏蔽，保存以后 可以在关键代码执行完毕时 再设置回来，解除信号的屏蔽。
   sigprocmask() 既 屏蔽信号，又 解除屏蔽。

   函数sigpending()可以获取在信号屏蔽期间，哪些信号来过。
   信号0是个特殊的存在，用于 测试 是否有发送信号的权限。信号0 没有实际的意义，也不会有额外的中断效果。

  信号的应用之 - 计时器(了解)
   计时器是实现一段时间之后，每隔一段时间产生一个信号
   计时器使用 setitimer() 、 getitimer() 进行设置和获取
   真实计时器产生的是 SIGALRM信号

  进程间通信 - IPC(Inter Process Communication)
   两个进程之间是不能直接访问对方的内存空间，而有些时候两个进程之间需要数据的交互，解决方案就是IPC。IPC技术包括很多，主要有：
    1 文件
    2 信号(signal)
    3 管道
    4 共享内存
    5 消息队列
    6 信号量集(semaphore arrays)
    7 网络socket
   ....
    其中，共享内存、消息队列和信号量集遵循相同的规范，统称为 XSI IPC。
    管道是 Unix中 最古老的IPC方式，因此现在较少使用。
    管道分为有名管道和无名管道，有名管道 以 管道文件做交互的媒介，适用于所有的IPC。 无名管道以 系统管理的管道文件做交互的媒介，因此不需要额外建立管道文件。无名管道只能用于 fork()创建的父子进程之间的IPC。
    管道在历史上是半双工的，现在都是全双工。



