回顾：
  多线程编程 - 基于CPU时间片技术实现的并行
  多线程编程的API(应用程序接口)：
   创建线程： pthread_create(pthread_t* id,0,
     void* (*fa)(void*),void* arg)
   如果主线程结束，所有的线程都会结束，因此要保证主线程最后结束，用pthread_join()。
   启动线程以后，可以使用pthread_join() 让主线程等待其他线程的结束。
   如果线程与其他线程无关，最好声明为 detach 分离，使用函数 pthread_detach()。
   线程共享进程的资源，因此可能出现数据的冲突，解决方案是线程同步技术： 互斥量、信号量、条件变量。
   其中互斥量的使用步骤：
    1 声明 pthread_mutex_t lock;
    2 初始化 pthread_mutex_init()
    3 上锁 pthread_mutex_lock()
    4 使用 
    5 解锁 pthread_mutex_unlock()
    6 销毁 pthread_mutex_destroy()

  UC的重点：(Unix系统下C开发人员)
   1 共享库的创建和使用。
   2 C程序的错误处理(用返回值代表错误)
   3 理解进程的内存空间、虚拟内存地址、内存页和内存映射，会使用malloc()和free()。
   4 文件的读写操作，stat()、access()、remove()、truncate()、rename()。
   5 递归访问目录(现在不着急，笔试之前背一下)
   6 创建进程的两种方案(fork() 和 vfok()+execl())，wait()和waitpid()
   7 信号的三部曲
   8 消息队列的使用
   9 网络编程，TCP和UDP编程模型
  10 多线程的编程
 今天：综合案例 - 基于网络编程和多线程技术
   写一个基于TCP的聊天室程序(UDP也行)
    聊天室 - 多个客户端可以互相聊天的程序。
    分服务器端和客户端，流程如下：
    1 先启动服务器端，服务器端应该是永不退出，可以用信号退出。用accept()等待客户端的连接。
    2 启动客户端，先输入一个名字，然后连接服务器，并把客户的名字发给服务器。
    3 服务器收到客户端的连接请求后，启动一个新的线程与客户端进行交互。
    4 服务器要记录所有客户端的socket，当客户端说话时，应该把这句话发给所有的客户端。
    5 客户端需要启动接收服务器的数据的线程。

