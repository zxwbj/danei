一.this指针 
   1.1 什么是this指针
   指向当前对象的指针 
       构造函数中 this指向正在被构建的对象首地址
       成员函数中 this代表调用这个函数的对象的
           首地址。
       a.show();
       b.show();
   1.2 this 指针的应用
       区分成员变量 和 函数参数
       this 可以作为函数参数
       this 能不能作为返回值 (实现连续操作) 
二.const 对象 和const 函数
   1.1 概念
   const对象就是加了 const修饰对象
        const A   var_a;
   const 函数 就是加了const修饰的成员函数
        class A{
	    public:
	    void  show()const{  
	        /* 这就是const 函数 */
	    }
	    void  show(){  
	        /* 这就是非const 函数 */
	    }
	};
   1.2 规则
   const 函数 和 非const函数可以构成重载关系
   const 对象只能调用 const函数 
   非const 对象优先调用 非const函数,如果没有
      非const函数 则调用const函数。
  
   const 函数中只能读成员变量 不能修改成员
       变量的值 也不能调用非const的成员函数。
   如果非要在const函数中去修改成员变量 只要
       在要修改的成员变量上 加一个mutable修饰

三.析构函数
   3.1  析构函数 和构造函数同名 只不过函数名
   前多了一个~ ,这个函数是无参的 所以一个类型
   中只有一个析构函数。
   3.2 作用
   可以在一个对象销毁之前 自动调用一次。
   用来释放内存  释放资源 

   3.3 内存相关的两个操作 
      构造函数   分配内存 
      析构函数   释放内存 
四. new  delete 比 malloc free 
    new 比malloc 多做了一些事
        如果类型中有类类型的成员 new会自动构建
	    这个成员。
        new 会 自动处理类型转换
	new 会 自动调用构造函数 
    delete  比free 多调用了一次析构函数

五.拷贝构造函数
   5.1  概念  
   本质上是一个构造函数 用拷贝数据的方式来
   构建对象。
   5.2 语法
   Person(const Person& p){
   
   }
   如果不给一个类型提供 拷贝构造函数 系统就
   默认提供一个拷贝构造函数。
   5.3 拷贝构造函数的调用时机
   使用一个已经存在的对象 去创建另外一个对象
   把对象传给一个函数的参数时 
   把一个对象 作为函数返回值时  
   5.4 为什么要有拷贝构造函数
   系统默认提供的拷贝构造函数 完成的是数据的
   逐字节拷贝。
   需要处理内存独立问题时  需要自定义拷贝构造
   函数。

六.静态成员 
   6.1 不需要对象 就可以调用函数,通过类型就可以
      完成这种函数的调用。
   6.2 静态成员变量
      静态成员变量 是整个类型共用的变量,
      普通成员变量 是对象独有的。
      静态成员变量 必须在类外进行初始化
      class A{
          int  x;
	  /* 这就是静态成员变量 */
	  static int  y;
      };
      /* 基本类型赋值成零  类类型默认调用
         无参构造 */
      静态成员变量类型 类名::变量名;
   6.3 静态成员函数 和 静态成员变量 
       静态成员函数中 只能(直接)访问静态成员。
       不能直接访问非静态成员。
       (因为静态函数中没有this 指针)

       静态成员 就是受类名作用域和权限限制
           的全局数据。
   6.4 单例模式的实现
       一个进程中 这种类型的对象 只有一个

       
     
     
   
    









