一.继承中构造和析构的调用
   1.1 调用顺序 
   构建子类对象时  一定会先调用父类的构造函数
   再调用自己的构造函数。
   析构函数的调用 和 构造调用的顺序相反。
   
   1.2 如果父类有多个构造函数  子类默认调用
   父类无参的构造函数，子类还可以指定调用
   父类的构造函数。
   可以使用初始化参数列表 指定调用父类的构造
   函数。
   
二.继承中 拷贝构造 和 赋值运算符的调用
   构建子类对象时 子类默认调用父类的拷贝构造函数
   和赋值运算符。
   但子类一旦自己的拷贝构造 和 赋值赋值运算符，
   则不再调用父类的 需要指定调用。

三.名字隐藏机制 (name  hide)
   3.1 在继承中 如果子类提供了 和 父类同名的数据
   则子类的数据 会把父类的数据隐藏掉。
   3.2 举例
   写一个父类  这个父类中有一个静态成员变量
   static  int  x;
   再写一个子类 继承这个父类  测试静态成员
   变量有没有名字隐藏机制。
    
四.多继承
   4.1  一个类 可以有多个直接父类 
   4.2 举例
      
      Phone       Camera       Mp3 
      
                  
		  IPhone
   4.3 语法
      class D:public A,private B,public C{
      
      };
		  
   4.4 多继承容易引入冲突 
      a.类名作用域 + 名字隐藏机制解决

      b. 1.抽取共同的成员变量 和 成员函数到
          更高层的类中。
         2.然后采用虚继承   
	 对直接的子类而言 没有明显的变化 还是
	 会把父类的数据复制下来。但对孙子类而
	 言共同的部分 不再从父类中复制 而是
	 从更高层的类中复制一份数据。
	  
五.多态
   5.1 概念
   当父类型指针(引用) 指向(引用)子类对象时,
   调用父类型中定义的虚函数,如果子类覆盖了
   父类的虚函数 则调用的表现是子类的否则是
   父类的。
   
   继承是构成多态的基础
   虚函数是关键 
   函数重写(over write)  是必备条件

   5.2 虚函数 
   如果一个成员函数 加了 virtual 修饰 则这个函数
   成为虚函数。
   class  A{
       public:
       /* 这是虚函数 */
       virtual void   show(){  }
   };

   5.3 函数重写 
      5.3.1 概念
      在子类中 提供了 和 父类同名的函数名
      并且这个函数 必须在父类中是虚函数,
      要求函数名相同 参数列表 返回值也必须
      相同。否则就是名字隐藏。
      5.3.2 函数重写 函数重载  名字隐藏
      函数重写:子类提供和父类同名的虚函数 
               要求函数名 参数列表 返回值相同
	       
      函数重载:同一作用域中  函数名相同 
          参数列表不同的函数构成重载关系。

      名字隐藏:子类提供和父类同名的数据 
          就会把父类的数据隐藏掉(虚函数除外). 

  5.4 多态的应用 
      函数参数 
          

      函数返回值 
      
  5.5 多态的底层实现 
      虚函数
      虚函数表指针
      虚函数表








                    
   


   